!function() {
    angular.module("ate.tester", [ "ngResource", "ngRoute", "ui.bootstrap", "ate.common", "gettext", "ngPrettyJson", "ngSanitize", "ngCookies", "angular-progress-arc" ]), 
    angular.module("ate.tester").run(function(a, b, c, d) {
        b.ate_user ? (c.getPermissions(b.ate_user), d.loadProfile(b.ate_user), a.path("/station")) : a.path("/login");
    });
}(), function() {
    function a(a) {
        var b = this;
        b.generateSerial = function() {
            return Math.floor(1e8 * Math.random() + 1);
        }, b.runTest = function() {
            if (!(countContainer.times <= 0)) for (i = 0; i < b.fixtures.length; i++) if ("end" == b.fixtures[i].run_status) {
                for (j = 0; j < fixtures.cavity.length; j++) fixtures.cavity[j].serial = b.generateSerial();
                b.fixtures[i].runTse();
            }
        }, b.startText = function(c, d) {
            for (b.fixtures = c, b.countContainer = d; d.times > 0; ) a(b.runTest, 100);
        };
    }
    angular.module("ate.tester").service("AutoTest", [ "$timeout", a ]);
}(), function() {
    function a(a, b, c) {
        var d = this;
        return d.batch = {
            batch_number: "",
            pn_cfg: "",
            pn_cfg_rev: "",
            batch_eval: !1,
            batch_conf: {}
        }, d.setBatchCookies = function(a, c, d) {
            b.batch_number = a, b.pn_cfg = c, b.pn_cfg_rev = d;
        }, d.getBatchFromCookies = function() {
            b.batch_number || b.pn_cfg && b.pn_cfg_rev ? (d.batch.batch_number = b.batch_number, 
            d.batch.pn_cfg = b.pn_cfg, d.batch.pn_cfg_rev = b.pn_cfg_rev) : c.path("/batch");
            var a = d.evaluateBatch(b.batch_number, b.pn_cfg, b.pn_cfg_rev);
            a.$promise.then(function(a) {
                0 == a.status ? (d.batch.batch_conf = a.data, d.batch.batch_eval = !0) : c.path("/batch");
            });
        }, d.batchResource = a("/tester/api/batch", {}, {
            update: {
                method: "PUT"
            }
        }), d.evaluateBatch = function(a, b, c) {
            return d.batchResource.get({
                batch_number: a,
                pn_cfg: b,
                pn_cfg_rev: c
            });
        }, d;
    }
    angular.module("ate.tester").service("BatchService", [ "$resource", "$cookies", "$location", a ]);
}(), angular.module("ate.tester").factory("d3Service", [ "$document", "$window", "$q", "$rootScope", function(a, b, c, d) {
    function e() {
        d.$apply(function() {
            f.resolve(b.d3);
        });
    }
    var f = c.defer(), g = {
        d3: function() {
            return f.promise;
        }
    }, h = a[0].createElement("script");
    h.type = "text/javascript", h.async = !0, h.src = "//cdnjs.cloudflare.com/ajax/libs/d3/3.4.1/d3.min.js", 
    h.onreadystatechange = function() {
        "complete" == this.readyState && e();
    }, h.onload = e;
    var i = a[0].getElementsByTagName("body")[0];
    return i.appendChild(h), g;
} ]), function() {
    function a(a, b, c) {
        var d = this;
        return d.getStationFixtures = function(b) {
            return a.get("/tester/api/fixture", {
                station_id: b._id,
                pn_cfg: b.pn_cfg,
                pn_cfg_rev: b.pn_cfg_rev
            });
        }, d.getFixtures = function() {
            return a.get("/tester/api/fixture");
        }, d.loadFixtures = function(d, e, f, g) {
            var h = "/tester/api/fixture";
            console.log("batch is:"), console.log(g), f._id && (h = h + "?station_id=" + f._id + "&pn_cfg=" + g.pn_cfg + "&pn_cfg_rev=" + g.pn_cfg_rev), 
            a.get(h).success(function(a) {
                if (0 == a.status) {
                    e.debug = a.debug, d.fixtures = [];
                    for (var f = 0; f < a.fixtures.length; f++) {
                        var h = [], i = a.fixtures[f].cavities / a.fixtures[f].horizontal_cavities;
                        console.log(a.fixtures[f].cavities), console.log(i);
                        for (var j = 0; j < a.fixtures[f].cavityInfo.length; j++) {
                            var k = {
                                idx: a.fixtures[f].cavityInfo.idx,
                                active: a.fixtures[f].cavityInfo[j].active,
                                require_serial: a.fixtures[f].require_serial,
                                percentage: 0,
                                serial: "",
                                enabled: a.fixtures[f].cavityInfo[j].active,
                                status: "idle",
                                test: "",
                                test_name: "",
                                verdict: "",
                                horizontal: parseInt(j / i),
                                vertical: j % i
                            };
                            h.push(k);
                        }
                        d.fixtures.push({
                            pn: a.fixtures[f].pn,
                            config: a.fixtures[f],
                            status: "idle",
                            lastStatusUpdate: !1,
                            runStatus: {
                                pre: 0,
                                execution_id: "",
                                cleanup: null,
                                timeElapsed: 0,
                                started: null,
                                state: "clear"
                            },
                            stats: {
                                "yield": 0,
                                failed: 0,
                                passed: 0
                            },
                            cavities: h,
                            clearSerial: !0,
                            devMode: !0,
                            ready_for_run: !1,
                            statusBar: {
                                description: "",
                                type: ""
                            }
                        });
                    }
                    for (var l = [], f = 0; f < a.fixtures.length; f++) console.log(a.fixtures[f].pn), 
                    l.push({
                        entity: a.fixtures[f].pn,
                        message_types: [ "all" ]
                    });
                    b.addFilters(l);
                } else e.debug = a.debug, e.error = a.error;
                for (var j = 0; j < d.fixtures.length; j++) c.fixtureStats(d.fixtures[j], g);
            }).error(function(a) {
                e.debug = a;
            });
        }, d.runTse = function(b, c) {
            b.status = "running", b.runStatus.state = "running", b.runStatus.tornado = "start";
            var d = {
                ip_address: b.config.ip_address,
                host: b.config.host,
                pn: b.config.pn,
                os: b.config.os,
                location: b.config.location
            }, e = {
                fixture_id: b.config.pn,
                cavity: {},
                configuration: c,
                rmt_srv: d
            };
            console.log("FixtureService runTse"), console.log(e);
            for (var f = 0, g = !0, h = "", i = 0; i < b.cavities.length; i++) f = i + 1, g = b.cavities[i].enabled ? !0 : !1, 
            h = b.cavities[i].serial ? b.cavities[i].serial : "", e.cavity[f.toString()] = {
                serial: h,
                state: g
            };
            var j = new Date();
            b.status = "running", b.runStatus.started = j.getTime(), b.error = "", console.log(e), 
            a.put("/tester/api/station", e).success(function(a) {
                console.log(a), 0 == a.status ? (b.debug = a.debug, b.runStatus.tornado = "complete", 
                b.runStatus.taskId = a.data.task_id) : (b.runStatus.tornado = "error", b.debug = a.debug, 
                b.error = a.error);
            }).error(function(a) {
                b.runStatus.tornado = "error", console.log("Request failed"), console.log(a);
            });
        }, d.stopTse = function(b, c) {
            if (b.runStatus.state = "stopping", 0 == c) var d = {
                task_id: b.runStatus.taskId,
                data: {
                    type: "STOP",
                    message: "TSE please, stop"
                }
            }; else var d = {
                task_id: b.runStatus.taskId
            };
            a.post("/tester/api/station", d).success(function(a) {
                console.log(a), 0 == a.status ? (b.statusBar.description = a.debug, b.statusBar.type = "warning", 
                b.runStatus.tornado = "complete", b.runStatus.state = "stop", b.runStatus.taskId = a.data.task_id) : (b.runStatus.tornado = "error", 
                b.statusBar.description = a.error, b.statusBar.type = "error");
            }).error(function(a) {
                b.runStatus.tornado = "error", console.log("Request failed"), console.log(a);
            });
        }, d.forceStopTse = function(b) {
            b.runStatus.state = "stopping";
            var c = {
                task_id: b.runStatus.taskId
            };
            a.post("/tester/api/station", c).success(function(a) {
                console.log(a), 0 == a.status ? (b.statusBar.description = a.debug, b.statusBar.type = "warning", 
                b.runStatus.tornado = "complete", b.runStatus.state = "stop", b.runStatus.taskId = a.data.task_id) : (b.runStatus.tornado = "error", 
                b.statusBar.description = a.error, b.statusBar.type = "error");
            }).error(function(a) {
                b.runStatus.tornado = "error", console.log("Request failed"), console.log(a);
            });
        }, d.calcFixtureProgress = function(a) {
            for (var b = 0, c = 0, d = 0; d < a.cavities.length; d++) a.cavities[d].enabled && (c++, 
            b += "failed" == a.cavities[d].status ? 100 : a.cavities[d].percentage);
            console.log(b), a.runStatus.percentage = b / c;
            var e = new Date();
            a.runStatus.timeElapsed = e.getTime() - a.runStatus.started, console.log(a.progress);
        }, d.clearFixture = function(a) {
            for (var b = 0; b < a.cavities.length; b++) a.devMode || (a.cavities[b].serial = ""), 
            a.cavities[b].status = "idle", a.cavities[b].percentage = 0, a.cavities[b].test = "";
            a.status = "idle", a.runStatus.percentage = 0, a.runStatus.started = 0, a.runStatus.timeElapsed = 0, 
            a.runStatus.cleanup = "", a.runStatus.tornado = "", a.runStatus.tasks = "", a.runStatus.tse = "", 
            a.runStatus.state = "clear";
        }, d;
    }
    angular.module("ate.tester").service("FixtureService", [ "$http", "WsClient", "StatisticsService", a ]);
}(), function() {
    function a() {
        var a = this;
        a.validateBatch = function(a) {
            return "8888" == a ? !0 : !1;
        };
    }
    angular.module("ate.tester").service("PseudoBatchService", [ a ]);
}(), function() {
    function a(a) {
        var b = this;
        return b.run = function(b) {
            var c = "/pseudo_runner/api/run?fixture_id=" + b;
            return a.get(c);
        }, b;
    }
    angular.module("ate.tester").service("PseudoRunnerService", [ "$http", a ]);
}(), function() {
    function a() {
        var a = this;
        a.validate = function(a) {
            return 8 == a.length ? !0 : !1;
        };
    }
    angular.module("ate.tester").service("PseudoSerialService", [ a ]);
}(), function() {
    function a(a) {
        var b = this;
        b.cavityReport = function(b, c, d, e) {
            var f = e + 1, g = {
                name: "" + f,
                horizontal: 0,
                vertical: 0
            }, h = {
                execution_id: b,
                fixture_id: c,
                cavity_id: g,
                serial_number: d,
                mtype: "cavity_report"
            };
            return a.post("/tester/api/report", h);
        }, b.fixtureReport = function(b, c) {
            var d = {
                execution_id: b,
                fixture_id: c,
                mtype: "fixture_report"
            };
            return a.post("/tester/api/report", d);
        };
    }
    angular.module("ate.tester").service("ReportService", [ "$http", a ]);
}(), function() {
    function a(a) {
        var b = this;
        b.openModal = function(b) {
            console.log("ReportModalService.openModal"), console.log(b);
            var c = a.open({
                templateUrl: "/static/src/tester/views/report_modal/report_modal.html",
                controller: "ReportModalController",
                resolve: {
                    data: function() {
                        return {
                            data: angular.copy(b)
                        };
                    }
                }
            });
            c.result.then(function() {
                console.log("Selected True");
            }, function(a) {
                angular.copy(a);
                console.log("Selected false");
            });
        };
    }
    angular.module("ate.tester").service("ReportModalService", [ "$modal", a ]);
}(), function() {
    function a(a) {
        var b = this;
        return b.runTse = function(b, c) {
            var d = {
                ip_address: b.ip_address,
                host: b.host,
                pn: b.pn,
                os: b.os,
                location: b.location
            }, e = {
                fixture_id: b.pn,
                cavity: {},
                configuration: c,
                rmt_srv: d
            };
            console.log("runTse"), console.log(e);
            for (var f = 0, g = !0, h = "", i = 0; i < b.cavityInfo.length; i++) f = i + 1, 
            g = b.cavityInfo[i].active ? !0 : !1, h = b.cavityInfo[i].serial ? b.cavityInfo[i].serial : "", 
            e.cavity[f.toString()] = {
                serial: h,
                state: g
            };
            b.run_status = "running", b.error = "", console.log(e), a.put("/tester/api/station", e).success(function(a) {
                console.log(a);
            }).error(function(a) {
                console.log("Request failed"), console.log(a);
            });
        }, b.calcFixtureProgress = function(a, b) {
            for (var c = 0, d = 0; d < b.length; d++) c += "fail" == b[d].verdict ? 100 : b[d].pre;
            console.log(c), a.progress = c / a.cavityInfo.length, console.log(a.progress);
        }, b;
    }
    angular.module("ate.tester").service("RunnerService", [ "$http", a ]);
}(), function() {
    function a(a, b) {
        return self.evaluateSerial = function(c, d) {
            for (var e = {
                cavities: [],
                setup: d
            }, f = !1, g = 0; g < c.cavities.length; g++) f = 0 == g ? !0 : !1, e.cavities.push({
                id: (g + 1).toString(),
                serial: c.cavities[g].serial,
                state: c.cavities[g].enabled,
                valid: !1,
                focus: f
            });
            b.debug("evaluating serial numbers", "SerialService", e), a.post("/tester/api/serial", e).success(function(a) {
                if (console.log(a), b.debug("Serial Validation", "SerialService", a), c.debug = a.debug, 
                0 == a.status) {
                    c.ready_for_run = a.data.ready_for_run, a.data.ready_for_run && (c.runStatus.state = "ready", 
                    b.debug("Ready to Run", "SerialService"));
                    for (var d = 0; d < a.data.cavities.length; d++) c.cavities[d].valid = a.data.cavities[d].valid, 
                    c.cavities[d].rejection = a.data.cavities[d].rejection, c.error = a.data.cavities[d].rejection;
                } else c.error = a.error;
            }).error(function(a) {
                c.error = "error in serial number validation", console.log("Request failed"), console.log(a), 
                b.critical("Server call failed" + a, "SerialService");
            });
        }, self;
    }
    angular.module("ate.tester").service("SerialService", [ "$http", "LoggerService", a ]);
}(), function() {
    function a(a) {
        var b = this;
        b.stationResource = a("/tester/api/station", {}, {
            update: {
                method: "PUT"
            }
        }), b.getStation = function() {
            return b.stationResource.get();
        };
    }
    angular.module("ate.tester").service("StationService", [ "$resource", a ]);
}(), function() {
    function a(a) {
        var b = this;
        return b.fixtureStats = function(b, c) {
            a.get("/tester/api/stats?fixture_pn=" + b.config.pn + "&batch_number=" + c.batch_number + "&pn_cfg=" + c.pn_cfg + "&pn_cfg_rev=" + c.pn_cfg_rev + "&stats_type=fixture").success(function(a) {
                b.debug = a.debug, 0 == a.status ? (console.log(a.data.statistics), b.stats = a.data.statistics) : b.error = a.error;
            }).error(function(a) {
                console.log(a), b.error = "failed to load statistics for fixture";
            });
        }, b.userStats = function(b, c) {
            a.get("/tester/api/stats?batch_number=" + c.batch_number + "&pn_cfg=" + c.pn_cfg + "&pn_cfg_rev=" + c.pn_cfg_rev + "&stats_type=user").success(function(a) {
                b.debug = a.debug, 0 == a.status ? (console.log(a.data.statistics), b.userStats = a.data.statistics) : b.error = a.error;
            }).error(function(a) {
                console.log(a), b.error = "failed to load statistics for current user";
            });
        }, b.batchStats = function(b, c) {
            b.batchStats = {
                "yield": 100,
                passed: 100,
                failed: 0
            }, a.get("/tester/api/stats?batch_number=" + c.batch_number + "&pn_cfg=" + c.pn_cfg + "&pn_cfg_rev=" + c.pn_cfg_rev + "&stats_type=batch").success(function(a) {
                b.debug = a.debug, 0 == a.status ? (console.log(a.data.statistics), b.batchStats = a.data.statistics) : b.error = a.error;
            }).error(function(a) {
                console.log(a), b.error = "failed to load statistics for current user";
            });
        }, b;
    }
    angular.module("ate.tester").service("StatisticsService", [ "$http", a ]);
}(), function() {
    function a(a, b) {
        var c = this;
        c.openModal = function(c) {
            var d = a.open({
                templateUrl: "/static/src/tester/views/user_interaction/user_interaction.html",
                controller: "UserInteractionModalController",
                resolve: {
                    data: function() {
                        return {
                            data: c
                        };
                    }
                }
            });
            d.result.then(function(a) {
                var c = angular.copy(a);
                console.log(c), c.method = "response", c.msg.value = !0, c.type = "private_message", 
                b.sendMessage(c), console.log("Selected True");
            }, function(a) {
                var c = angular.copy(a);
                c.method = "response", c.msg.value = !0, c.type = "private_message", b.sendMessage(c), 
                console.log("Selected false");
            });
        };
    }
    angular.module("ate.tester").service("UserInteractionService", [ "$modal", "WsClient", "UserInteractionModalController", a ]);
}(), function() {
    function a(a, b, c, d, e, f, g, h, i, j, k) {
        var l = this;
        l.error = "", l.debug = "", l.reportData = "sfdgsdfgsdfg", l.fixtures = [], l.batch = {
            batch_number: "",
            pn_cfg: "test_b03",
            pn_cfg_rev: "A",
            batch_eval: !1
        }, a.items = [ "item1", "item2", "item3" ], l.autoCount = {
            times: 6
        }, l.startAutoTest = function() {
            h.startAutoTest(l.fixtures, l.autoCount);
        }, l.validate_serial = function(a, b) {
            if (a) {
                console.log("validate_serial:" + a + ":" + b);
                var c = j.evaluateSerial(a, b, l.batch.batch_conf);
                c.$save(function(a) {
                    l.debug = a.debug, 0 == a.status ? console.log(a) : l.error = a.error;
                });
            }
        }, l.stopAutoTest = function() {
            l.autoCount.times = 0;
        }, l.loadFixtures = function() {
            b.get("/tester/api/fixture").success(function(a) {
                console.log("we have fixtures");
                for (var b = [], c = 0; c < a.fixtures.length; c++) console.log(a.fixtures[c].pn), 
                b.push({
                    entity: a.fixtures[c].pn,
                    message_types: [ "all" ]
                });
                g.addFilters(b), l.fixtures = a.fixtures;
            }).error(function(a) {
                console.log(a), l.debug = a;
            });
        }, l.loadFixtures(), l.runTse = function(a) {
            return console.log(l.batch), a.executionTime = 0, d.runTse(a, l.batch);
        }, l.evaluateBatch = function() {
            delete l.batch.batch_conf, req = f.evaluateBatch(l.batch.batch_number, l.batch.pn_cfg, l.batch.pn_cfg_rev), 
            req.$promise.then(function(a) {
                0 == a.status ? (l.batch.batch_conf = a.data, l.batch.batch_eval = !0) : l.batch.error = a.error;
            });
        }, l.tseCallback = function(b) {
            console.log("in tse callback"), console.log(b);
            for (var c = !1, e = 0; e < l.fixtures.length; e++) if (l.fixtures[e].pn == b.info.fixture_id) {
                c = l.fixtures[e];
                break;
            }
            if (!c) return void console.log("fixture not found:" + b.info.fixture_id);
            if (c.run_status = b.info.stage, "start" == b.info.stage && (c.execution_id = b.info.execution_id), 
            "running" == b.info.stage) {
                for (var f = 0; f < b.info.cavities.length; f++) c.cavityInfo[f] && (c.cavityInfo[f].runStatus = b.info.cavities[f]);
                d.calcFixtureProgress(c, b.info.cavities);
            }
            "end" == b.info.stage && console.log("stage=stop"), "cleanup" == b.info.stage && (console.log(b), 
            console.log("stage=cleanup")), a.$apply();
        }, g.setCallback("tse", l.tseCallback), l.clearFixture = function(a) {
            for (var b = 0; b < a.cavityInfo.length; b++) a.cavityInfo[b].serial = "", a.cavityInfo[b].runStatus = {};
            a.run_status = !1, a.progress = 0, a.execution_id = "";
        }, l.cavityReport = function(a, b, c) {
            report = k.cavityReport(a.execution_id, a.pn, b, c), report.success(function(a) {
                l.reportData = a, l.openModal();
            }).error(function(a) {
                console.log(a), l.debug = a.debug, l.error = a.error;
            });
        }, l.fixtureReport = function(a) {
            a.execution_id && (report = k.fixtureReport(a.execution_id, a.pn), report.success(function(a) {
                l.reportData = a, l.openModal();
            }).error(function(a) {
                console.log(a), l.debug = a.debug, l.error = a.error;
            }));
        }, l.openModal = function() {
            var a = c.open({
                templateUrl: "/static/src/tester/views/report_modal/report_modal.html",
                controller: "ModalInstanceCtrl",
                resolve: {
                    items: function() {
                        return l.reportData;
                    }
                }
            });
            a.result.then(function() {
                console.log("Selected True");
            }, function(a) {
                angular.copy(a);
                console.log("Selected false");
            });
        }, l.fixtureContainer = {}, l.errorContainer = {}, e.loadFixtures(l.fixtureContainer, l.errorContainer, !1), 
        l.open = function(a) {
            var b = c.open({
                templateUrl: "/static/src/tester/views/report_modal/report_modal.html",
                controller: "ModalInstanceCtrl",
                resolve: {
                    data: function() {
                        return {
                            data: a
                        };
                    }
                }
            });
            b.result.then(function(a) {
                var b = angular.copy(a);
                console.log(b), b.method = "response", b.msg.value = !0, b.type = "private_message", 
                g.sendMessage(b), console.log("Selected True");
            }, function(a) {
                var b = angular.copy(a);
                b.method = "response", b.msg.value = !0, b.type = "private_message", g.sendMessage(b), 
                console.log("Selected false");
            });
        }, l.tfTesterInteractionCallback = function(a) {
            console.log("in userInteractionCallback"), console.log(a), alert(a.msg.message);
            var b = angular.copy(a);
            b.method = "response", b.msg.value = !0, b.type = "private_message", console.log(b), 
            g.sendMessage(b);
        }, g.setCallback("tf_tester_interaction", l.tfTesterInteractionCallback);
    }
    angular.module("ate.tester").controller("ModalInstanceCtrl", function(a, b, c) {
        a.items = c, console.log("ModalInstanceCtrl"), console.log(c), a.selected = {
            item: a.items[0]
        }, a.ok = function() {
            b.close(a.selected.item);
        }, a.cancel = function() {
            b.dismiss("cancel");
        };
    }), angular.module("ate.tester").controller("DeveloperController", [ "$scope", "$http", "$modal", "RunnerService", "FixtureService", "BatchService", "WsClient", "AutoTest", "PseudoRunnerService", "SerialService", "ReportService", "ReportModalService", a ]);
}(), function() {
    function a() {
        var a = this;
        a.log = function(a) {
            console.console.log(a);
        };
    }
    angular.module("ate.tester").controller("HelpController", [ a ]);
}(), function() {
    function a(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {
        var p = this;
        p.error = "", p.debug = "", p.devMode = !0, p.showDebug = !1, p.datetimeFormat = "HH:mm:ss", 
        p.uiLanguage = m.getuiLanguage(), p.station = !1, p.fixtures = [], p.userStats = {
            "yield": 0,
            passed: 0,
            failed: 0
        }, p.batchStats = {
            "yield": 0,
            passed: 0,
            failed: 0
        }, p.batch = g.batch, p.setDevMode = function(a) {
            p.batch.batch_conf.launcher.develop = a;
            for (var b = 0; b < p.fixtures.length; b++) p.fixtures[b].devMode = a;
        }, p.help = function(a) {
            l.modalHelp(a);
        }, p.cavityReport = function(a, b, c) {
            var d = j.cavityReport(a.runStatus.execution_id, a.config.pn, b, c);
            d.success(function(b) {
                p.openModal(b), a.debug = b.debug;
            }).error(function(b) {
                console.log(b), a.debug = b.debug, a.error = b.error;
            });
        }, p.fixtureReport = function(a) {
            return a.runStatus.execution_id ? (report = j.fixtureReport(a.runStatus.execution_id, a.config.pn), 
            void report.success(function(a) {
                p.openModal(a);
            }).error(function(b) {
                console.log(b), a.debug = b.debug, a.error = b.error;
            })) : void (a.debug = "No Execution Id");
        }, p.openModal = function(a) {
            var b = c.open({
                templateUrl: "/static/src/tester/views/report_modal/report_modal.html",
                controller: "ReportModalInstanceCtrl",
                size: "lg",
                resolve: {
                    items: function() {
                        return a;
                    }
                }
            });
            b.result.then(function() {
                console.log("Selected True");
            }, function(a) {
                angular.copy(a);
                console.log("Selected false");
            });
        }, p.loadFixtures = function() {
            p.batch.batch_eval ? p.station ? f.loadFixtures(p, p, p.station, p.batch) : console.log("station is not yet loaded, can not load fixtures") : console.log("batch is not yet loaded, can not load fixtures");
        }, p.evaluateBatch = function() {
            delete p.batch.batch_conf, req = g.evaluateBatch(p.batch.batch_number, p.batch.pn_cfg, p.batch.pn_cfg_rev), 
            req.$promise.then(function(a) {
                0 == a.status ? (p.batch.batch_conf = a.data, p.batch.batch_eval = !0, p.loadFixtures(), 
                i.batchStats(p, p.batch), i.userStats(p, p.batch)) : p.batch.error = a.error;
            });
        }, p.init = function() {
            n.debug("init start", "StationController"), g.getBatchFromCookies(), p.evaluateBatch();
            var a = e.getStation();
            a.$promise.then(function(a) {
                0 == a.status ? (p.station = a.station, p.loadFixtures()) : p.error = a.error;
            }), n.debug("init completed", "StationController");
        }, p.init(), p.evaluateSerial = function(a) {
            n.log("Evaluating serial number", "Station", a), k.evaluateSerial(a, p.batch);
        }, p.runTse = function(a) {
            return o.canRunTse() ? a.ready_for_run ? f.runTse(a, p.batch) : void (a.error = "Fixture is not ready make sure all serial number are valid") : (p.error = "Can not run Test Sequence - one of the essential services ore offline", 
            !1);
        }, p.stopTse = function(a) {
            return f.stopTse(a, !1);
        }, p.terminateTse = function(a) {
            return f.terminateTse(a);
        }, p.forceStopTse = function(a) {
            return f.stopTse(a, !0);
        }, p.clearFixture = function(a) {
            return f.clearFixture(a);
        }, p.tseCallback = function(a) {
            console.log("in tse callback"), console.log(a);
            for (var c = !1, d = 0; d < p.fixtures.length; d++) if (p.fixtures[d].pn == a.info.fixture_id) {
                c = p.fixtures[d];
                break;
            }
            if (!c) return void console.log("fixture not found:" + a.info.fixture_id);
            if (c.status = a.info.stage, "start" == a.info.stage && (c.runStatus.execution_id = a.info.execution_id, 
            c.runStatus.tse = "start"), "running" == a.info.stage) {
                c.runStatus.state = "running";
                for (var e = 0; e < a.info.cavities.length; e++) "failed" != c.cavities[e].status && c.cavities[e].enabled && (c.cavities[e].test_name = a.info.cavities[e].test_name, 
                c.cavities[e].percentage = a.info.cavities[e].percentage, a.info.cavities[e].running || (a.info.cavities[e].verdict ? c.cavities[e].status = "success" : (c.cavities[e].status = "failed", 
                c.cavities[e].atp_code = "010")));
            }
            f.calcFixtureProgress(c), "end" == a.info.stage && (c.runStatus.tse = "end", console.log("stage=end")), 
            "cleanup" == a.info.stage && (console.log(a), n.debug("clean was sent", "tse", {}), 
            c.runStatus.cleanup = a.info.status, console.log("stage=cleanup")), "tasks" == a.info.stage && ("start" == a.info.action && (n.log("tasks start", "StationController"), 
            c.runStatus.tasks = "start"), "exception" == a.info.action && (n.critical("exception in tasks", "StationController", a), 
            console.log("stage=exception"), c.runStatus.tasks = "start", c.testCompleted = !0, 
            c.status = "failed", c.debug = a.info.action.error, c.runStatus.tasks = "error", 
            c.runStatus.state = "stop"), "end" == a.info.action && (n.log("tasks end", "StationController"), 
            c.runStatus.percentage = 100, c.runStatus.state = "stop", c.testCompleted = !0, 
            c.status = "success", c.runStatus.tasks = "complete", i.fixtureStats(c, p.batch), 
            i.batchStats(p, p.batch), i.userStats(p, p.batch))), b.$apply();
        }, p.openTfTesterInteractionModal = function(a) {
            console.log(a);
            var b = c.open({
                templateUrl: "/static/src/tester/views/tse_interaction_modal/tse_interaction_modal.html",
                controller: "TseModalInstanceCtrl",
                windowClass: "center-modal",
                size: "lg",
                resolve: {
                    items: function() {
                        return a;
                    }
                }
            });
            b.result.then(function(b) {
                var c = angular.copy(b);
                angular.extend(c, a), c.method = "response", c.type = "private_message", d.sendMessage(c), 
                console.log("Selected True");
            }, function(b) {
                var c = angular.copy(b);
                angular.extend(c, a), c.method = "response", c.type = "private_message", d.sendMessage(c), 
                console.log("Selected false");
            });
        }, p.tfTesterInteractionCallback = function(a) {
            n.log("userInteractionCallback", "StationController", a), b.openTfTesterInteractionModal(a), 
            b.$apply();
        }, p.tmpOpenInteraction = function() {
            var a = {
                data: {
                    title: "Example tmpOpenInteraction",
                    msg: "Some message",
                    options: [ 1, 2, 3, 4, 5, 6 ]
                },
                timeout: 1e4
            };
            p.openTfTesterInteractionModal(a);
        }, d.setCallback("tse", p.tseCallback), d.setCallback("tf_tester_interaction", p.openTfTesterInteractionModal);
    }
    angular.module("ate.tester").controller("StationController", [ "$http", "$scope", "$modal", "WsClient", "StationService", "FixtureService", "BatchService", "RunnerService", "StatisticsService", "ReportService", "SerialService", "ModalHelpService", "LanguageService", "LoggerService", "AlertService", a ]);
}(), function() {
    function a(a, b, c) {
        a.data = c.data, a.ok = function() {
            b.close(a.data);
        }, a.cancel = function() {
            b.dismiss(a.data);
        };
    }
    angular.module("ate.tester").controller("UserInteractionModalController", [ "$scope", "$modalInstance", a ]);
}(), function() {
    function a(a) {
        a.when("/", {
            templateUrl: "/static/src/tester/views/station/station.html",
            controller: "StationController",
            controllerAs: "station"
        }).when("/login", {
            templateUrl: "/static/src/common/auth/views/login/login.html",
            controller: "LoginController",
            controllerAs: "login"
        }).when("/help", {
            templateUrl: "/static/src/tester/views/help/help.html",
            controller: "HelpController",
            controllerAs: "help"
        }).when("/developer", {
            templateUrl: "/static/src/tester/views/developer/developer.html",
            controller: "DeveloperController",
            controllerAs: "developer",
            resolve: {
                factory: b
            }
        }).when("/station", {
            templateUrl: "/static/src/tester/views/station/station.html",
            controller: "StationController",
            controllerAs: "station",
            resolve: {
                factory: b
            }
        }).when("/pseudo_station", {
            templateUrl: "/static/src/tester/views/pseudo_station/pseudo_station.html",
            controller: "PseudoStationController",
            controllerAs: "station",
            resolve: {
                factory: b
            }
        }).when("/batch", {
            templateUrl: "/static/src/tester/views/batch/batch.html",
            controller: "BatchController",
            controllerAs: "batch",
            resolve: {
                factory: b
            }
        }).otherwise({
            redirectTo: "/station"
        });
    }
    var b = function(a) {
        return a.requireLogin();
    };
    angular.module("ate.tester").config([ "$routeProvider", a ]);
}();